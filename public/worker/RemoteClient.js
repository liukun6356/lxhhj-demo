define(['/arcgis-js-api/kernel.js', '/arcgis-js-api/core/Error.js', '/arcgis-js-api/core/events.js', '/arcgis-js-api/core/maybe.js', '/arcgis-js-api/core/promiseUtils.js', '/arcgis-js-api/core/workers/registry.js', '/arcgis-js-api/core/workers/utils.js', '/arcgis-js-api/support/revision.js'], (function (kernel_js, s, events_js, maybe_js, promiseUtils_js, registry_js, utils_js, revision_js) { 'use strict';

	/*
	All material copyright ESRI, All Rights Reserved, unless otherwise specified.
	See https://js.arcgis.com/4.27/esri/copyright.txt for details.
	*/
	const{CLOSE:m,ABORT:f,INVOKE:v,RESPONSE:M,OPEN_PORT:k,ON:j}=utils_js.MessageType,y=2;class I{constructor(e){this._timer=null,this._cancelledJobIds=new Set,this._invokeMessages=[],this._invoke=e,this._timer=null,this._process=this._process.bind(this);}push(e){e.type===utils_js.MessageType.ABORT?this._cancelledJobIds.add(e.jobId):(this._invokeMessages.push(e),null===this._timer&&(this._timer=setTimeout(this._process,0)));}clear(){this._invokeMessages.length=0,this._cancelledJobIds.clear(),this._timer=null;}_process(){this._timer=null;for(const e of this._invokeMessages)this._cancelledJobIds.has(e.jobId)||this._invoke(e);this._cancelledJobIds.clear(),this._invokeMessages.length=0;}}class J{static connect(e){const s=new MessageChannel;let t;t="function"==typeof e?new e:"default"in e&&"function"==typeof e.default?new e.default:e;const o=new J(s.port1,{channel:s,client:t},(()=>null));return "object"==typeof t&&"remoteClient"in t&&(t.remoteClient=o),J.clients.set(o,t),s.port2}static loadWorker(e){const s=registry_js.registry[e];return s?s():Promise.resolve(null)}constructor(e,s,t){this._port=e,this._getNextJob=t,this._outJobs=new Map,this._inJobs=new Map,this._invokeQueue=new I((e=>this._onInvokeMessage(e))),this._client=s.client,this._onMessage=this._onMessage.bind(this),this._channel=s.channel,this._schedule=s.schedule,this._port.addEventListener("message",this._onMessage),this._port.start();}close(){this._post({type:m}),this._close();}isBusy(){return this._outJobs.size>0}invoke(e,t,l){const a=l?.signal,h=l?.transferList;if(!this._port)return Promise.reject(new s("worker:port-closed",`Cannot call invoke('${e}'), port is closed`,{methodName:e,data:t}));const _=utils_js.newJobId();return new Promise(((s,l)=>{if(promiseUtils_js.isAborted(a))return this._processWork(),void l(promiseUtils_js.createAbortError());const c=promiseUtils_js.onAbort(a,(()=>{const e=this._outJobs.get(_);e&&(this._outJobs.delete(_),this._processWork(),maybe_js.removeMaybe(e.abortHandle),this._post({type:f,jobId:_}),l(promiseUtils_js.createAbortError()));})),p={resolve:s,reject:l,abortHandle:c,debugInfo:e};this._outJobs.set(_,p),this._post({type:v,jobId:_,methodName:e,abortable:null!=a},t,h);}))}on(e,s){const t=new MessageChannel;function o(e){s(e.data);}return this._port.postMessage({type:utils_js.MessageType.ON,eventType:e,port:t.port2},[t.port2]),t.port1.addEventListener("message",o),t.port1.start(),{remove(){t.port1.postMessage({type:utils_js.MessageType.CLOSE}),t.port1.close(),t.port1.removeEventListener("message",o);}}}jobAdded(){this._processWork();}openPort(){const e=new MessageChannel;return this._post({type:k,port:e.port2}),e.port1}_processWork(){if(this._outJobs.size>=y)return;const e=this._getNextJob();if(!e)return;const{methodName:s,data:t,invokeOptions:o,resolver:n}=e;this.invoke(s,t,o).then((e=>n.resolve(e))).catch((e=>n.reject(e)));}_close(){this._channel&&(this._channel=void 0),this._port.removeEventListener("message",this._onMessage),this._port.close(),this._outJobs.forEach((e=>{maybe_js.removeMaybe(e.abortHandle),e.reject(promiseUtils_js.createAbortError(`Worker closing, aborting job calling '${e.debugInfo}'`));})),this._inJobs.clear(),this._outJobs.clear(),this._invokeQueue.clear(),this._port=null,this._client=null,this._schedule=null;}_onMessage(e){null!=this._schedule?this._schedule((()=>this._processMessage(e))):this._processMessage(e);}_processMessage(e){const s=utils_js.receiveMessage(e);if(s)switch(s.type){case M:this._onResponseMessage(s);break;case v:this._invokeQueue.push(s);break;case f:this._onAbortMessage(s);break;case m:this._onCloseMessage();break;case k:this._onOpenPortMessage(s);break;case j:this._onOnMessage(s);}}_onAbortMessage(e){const s=this._inJobs,t=e.jobId,o=s.get(t);this._invokeQueue.push(e),o&&(o.controller&&o.controller.abort(),s.delete(t));}_onCloseMessage(){const e=this._client;this._close(),e&&"destroy"in e&&J.clients.get(this)===e&&e.destroy(),J.clients.delete(this),e?.remoteClient&&(e.remoteClient=null);}_onInvokeMessage(e){const{methodName:s,jobId:t,data:o,abortable:n}=e,r=n?new AbortController:null,i=this._inJobs;let h,c=this._client,_=c[s];try{if(!_&&s&&s.includes(".")){const e=s.split(".");for(let s=0;s<e.length-1;s++)c=c[e[s]],_=c[e[s+1]];}if("function"!=typeof _)throw new TypeError(`${s} is not a function`);h=_.call(c,o,{client:this,signal:r?r.signal:null});}catch(p){return void this._post({type:M,jobId:t,error:utils_js.toInvokeError(p)})}promiseUtils_js.isPromiseLike(h)?(i.set(t,{controller:r,promise:h}),h.then((e=>{i.has(t)&&(i.delete(t),this._post({type:M,jobId:t},e));}),(e=>{i.has(t)&&(i.delete(t),promiseUtils_js.isAbortError(e)||this._post({type:M,jobId:t,error:utils_js.toInvokeError(e||{message:`Error encountered at method ${s}`})}));}))):this._post({type:M,jobId:t},h);}_onOpenPortMessage(e){new J(e.port,{client:this._client},(()=>null));}_onOnMessage(e){const{port:s}=e,o=this._client.on(e.eventType,(e=>{s.postMessage(e);})),n=events_js.on(e.port,"message",(e=>{const t=utils_js.receiveMessage(e);t?.type===utils_js.MessageType.CLOSE&&(n.remove(),o.remove(),s.close());}));}_onResponseMessage(e){const{jobId:t,error:n,data:r}=e,i=this._outJobs;if(!i.has(t))return;const l=i.get(t);i.delete(t),this._processWork(),maybe_js.removeMaybe(l.abortHandle),n?l.reject(s.fromJSON(JSON.parse(n))):l.resolve(r);}_post(e,s,t){return utils_js.postMessage(this._port,e,s,t)}}J.kernelInfo={buildDate:revision_js.buildDate,fullVersion:kernel_js.fullVersion,revision:revision_js.commitHash},J.clients=new Map;

	return J;

}));
//# sourceMappingURL=RemoteClient.js.map
